#include "advancingFronReconstruct.h"

#include <CGAL/Advancing_front_surface_reconstruction.h>
#include <CGAL/structure_point_set.h>
#include <CGAL/linear_least_squares_fitting_3.h>

#include "yutils/FileNameUtils.h"

using Point_3 = Kernel::Point_3;
using Vector_3 = Kernel::Vector_3;
using SMesh = CGAL::Surface_mesh<Point_3>;
using Facet = std::array<std::size_t, 3>;
using Plane_3 = Kernel::Plane_3;

using Point_set = CGAL::Point_set_3<Point_3, Vector_3>;

namespace {

    //****Radius
    struct Radius {

        double bound;

        Radius(double bound)
            : bound(bound)
        {}

        template <typename AdvancingFront, typename Cell_handle>
        double operator() (const AdvancingFront& adv, Cell_handle& c,
            const int& index) const
        {
            if (bound == 0) {
                return adv.smallest_radius_delaunay_sphere(c, index);
            }

            double d = 0;
            d = sqrt(squared_distance(c->vertex((index + 1) % 4)->point(),
                c->vertex((index + 2) % 4)->point()));
            if (d > bound) return adv.infinity();
            d = sqrt(squared_distance(c->vertex((index + 2) % 4)->point(),
                c->vertex((index + 3) % 4)->point()));
            if (d > bound) return adv.infinity();
            d = sqrt(squared_distance(c->vertex((index + 1) % 4)->point(),
                c->vertex((index + 3) % 4)->point()));
            if (d > bound) return adv.infinity();

            return adv.smallest_radius_delaunay_sphere(c, index);
        }
    };

    template <typename Structuring>
    struct Priority_with_structure_coherence {

        Structuring& structuring;
        double bound;

        Priority_with_structure_coherence(Structuring& structuring,
            double bound)
            : structuring(structuring), bound(bound)
        {}

        template <typename AdvancingFront, typename Cell_handle>
        double operator() (AdvancingFront& adv, Cell_handle& c,
            const int& index) const
        {
            // If perimeter > bound, return infinity so that facet is not used
            if (bound != 0)
            {
                double d = 0;
                d = sqrt(squared_distance(c->vertex((index + 1) % 4)->point(),
                    c->vertex((index + 2) % 4)->point()));
                if (d > bound) return adv.infinity();
                d += sqrt(squared_distance(c->vertex((index + 2) % 4)->point(),
                    c->vertex((index + 3) % 4)->point()));
                if (d > bound) return adv.infinity();
                d += sqrt(squared_distance(c->vertex((index + 1) % 4)->point(),
                    c->vertex((index + 3) % 4)->point()));
                if (d > bound) return adv.infinity();
            }

            Facet f = { { c->vertex((index + 1) % 4)->info(),
                         c->vertex((index + 2) % 4)->info(),
                         c->vertex((index + 3) % 4)->info() } };

            double weight = 100. * (5 - structuring.facet_coherence(f));

            return weight * adv.smallest_radius_delaunay_sphere(c, index);
        }

    };
}

surfaceReconstruct::surfaceReconstruct(std::string pointPath)
    : _pointPath(pointPath)
{

}

surfaceReconstruct::~surfaceReconstruct()
{

}

void surfaceReconstruct::doReconstruct()
{
    std::string out_file = yUtils::getNameLessExtension(_pointPath);

    std::vector<Point_3> vPoints;
    std::vector<Vector_3> vNormals;
    std::ifstream stream(_pointPath);
    if (!stream)
    {
        std::cerr << "Error: cannot read file " << _pointPath << std::endl;
        return ;
    }
    Point_3 p;
    Vector_3 v;
    while (stream >> p >> v) {
        vPoints.emplace_back(p);
        vNormals.emplace_back(v);
    }
    std::cout << vPoints.size() << " input vPoints" << std::endl;
    vPoints.shrink_to_fit();
    vNormals.shrink_to_fit();
    if (vPoints.empty())
        return;

    int reconstruction_choice = 1;
    if (reconstruction_choice == 1) // Advancing front
    {
        std::vector<Facet> facets;
        SMesh m;

        Radius raduis(2);
        double radius_ratio_bound = 4;
        CGAL::advancing_front_surface_reconstruction(vPoints.begin(), vPoints.end(),
            std::back_inserter(facets), raduis, radius_ratio_bound, 0.5);
        std::cout << facets.size() << " facet(s) generated by reconstruction." << std::endl;
        std::vector<Point_3> vertices;
        vertices.reserve(vPoints.size());
        std::copy(vPoints.begin(), vPoints.end(), std::back_inserter(vertices));
        SMesh output_mesh;
        CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh(vertices, facets, output_mesh);
        std::ofstream f(out_file + "_advanceFront.off");
        CGAL::write_off(f, output_mesh);
        f.close();
    }
}
